// package hqmodule
package main

import (
	"database/sql"
	"flag"
	"os"
	"quant/hqmodule/base"
	"quant/hqmodule/marketdata/readSH"
	"quant/hqmodule/marketdata/vss"
	"sync"
	"time"
	redis "util/redis"

	"github.com/Workiva/go-datastructures/queue"
	_ "github.com/go-sql-driver/mysql"
	zmq "github.com/pebbe/zmq3"
	log "github.com/thinkboy/log4go"
	"github.com/widuu/goini"
)

var (
	rb        *queue.RingBuffer
	redisRb   *queue.RingBuffer
	mysqlRb   *queue.RingBuffer
	RedisPool *redis.ConnPool

	tstart time.Time
	conf   *goini.Config
)

// 将行情数据发送到zeroMQ
func sendToZMQ() {
	log.Info("-----sendToZMQ-----")
	publisher, _ := zmq.NewSocket(zmq.PUB)
	defer publisher.Close()
	publisher.Bind(conf.GetValue("hqmodule", "publish_addr"))

	log.Info("------publisher start on:%v------\n", conf.GetValue("hqmodule", "publish_addr"))
	//Ensure subscriber connection has time to complete
	//time.Sleep(time.Second)

	var topic string
	t0 := time.Now()
	i := 0
	for {

		msg, _ := rb.Get()
		b := msg.([]byte)
		if b[19] == 164 {
			topic = string(b[10:19])
		} else if b[20] == 164 {
			topic = string(b[10:20])
		} else if b[21] == 164 {
			topic = string(b[10:21])
		}
		log.Info("send len %d, topic %s, rb.len %d", len(b), topic, rb.Len())
		_, err := publisher.SendMessage(topic, b[1:])
		if err != nil {
			log.Error("publisher sendMessage: ", err)
		}

		i++
		if i%1000 == 0 {
			log.Error("put %d with %v", i, time.Now().Sub(t0))
		}

		//		if b[0] == 0x1 {
		//			if b[17] != 32 && b[18] != 32 {
		//				topic = string(b[11:19]) + ".SZ"
		//			}else {
		//				topic = string(b[11:17]) + ".SZ"
		//			}
		//			log.Info("send len %d, topic %s, rb.len %d", len(b), topic, rb.Len())
		//			_, err := publisher.SendMessage(topic, b[1:])
		//			if err != nil {
		//				log.Error("publisher sendMessage: ", err)
		//			}
		//			time.Sleep(time.Nanosecond)

		//		} else if b[0] == 0x2 {
		//			topic = string(b[11:17]) + ".SH"
		//			log.Info("send len %d, topic %s, rb.len %d", len(b), topic, rb.Len())

		//			_, err := publisher.SendMessage(topic, b[1:])
		//			if err != nil {
		//				log.Error("publisher sendMessage: ", err)
		//			}
		//			time.Sleep(time.Nanosecond)
		//		}
	}
}

func sendToMysql() {
	log.Info("-----------sendToMysql-----------")

	// Open database connection
	db, err := sql.Open("mysql", conf.GetValue("mysql", "mysqlusername")+":"+conf.GetValue("mysql", "mysqlpwd")+"@"+conf.GetValue("mysql", "mysqlurl"))
	if err != nil {
		log.Error("open database connection: ", err)
	}
	defer db.Close()

	tx, err := db.Begin()
	if err != nil {
		log.Error("db.Begin err: ", err)
	}
	stmt, err := tx.Prepare("REPLACE INTO realtimemarketdata(Code,Time,Status,PreClose,Open,High,Low,Last,AskPrice1,AskPrice2,AskPrice3,AskPrice4,AskPrice5,AskPrice6,AskPrice7,AskPrice8,AskPrice9,AskPrice10,AskVol1,AskVol2,AskVol3,AskVol4,AskVol5,AskVol6,AskVol7,AskVol8,AskVol9,AskVol10,BidPrice1,BidPrice2,BidPrice3,BidPrice4,BidPrice5,BidPrice6,BidPrice7,BidPrice8,BidPrice9,BidPrice10,BidVol1,BidVol2,BidVol3,BidVol4,BidVol5,BidVol6,BidVol7,BidVol8,BidVol9,BidVol10,NumTrades,Volume,Turnover,TotalBidVol,TotalAskVol,WeightedAvgBidPrice,WeightedAvgAskPrice,IOPV,YieldToMaturity,HighLimited,LowLimited) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)")
	if err != nil {
		log.Error("db.Prepare err: ", err)
	}
	_ = stmt
	t0 := time.Now()
	i := 0
	for {
		msg, _ := mysqlRb.Get()
		//		_, err := stmt.Exec("test",123,"1",123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123)
		//		if err != nil {
		//			log.Error("error: %v", err)
		//		}

		if mkd, ok := msg.(base.Marketdata); ok {
			log.Info("replace into code %s, mysqlRb.len %d", mkd.Code, mysqlRb.Len())
			_, err := stmt.Exec(mkd.Code, mkd.Time, mkd.Status, mkd.PreClose, mkd.Open, mkd.High, mkd.Low, mkd.Match, mkd.AskPrice[0], mkd.AskPrice[1], mkd.AskPrice[2], mkd.AskPrice[3], mkd.AskPrice[4], mkd.AskPrice[5], mkd.AskPrice[6], mkd.AskPrice[7], mkd.AskPrice[8], mkd.AskPrice[9], mkd.AskVol[0], mkd.AskVol[1], mkd.AskVol[2], mkd.AskVol[3], mkd.AskVol[4], mkd.AskVol[5], mkd.AskVol[6], mkd.AskVol[7], mkd.AskVol[8], mkd.AskVol[9], mkd.BidPrice[0], mkd.BidPrice[1], mkd.BidPrice[2], mkd.BidPrice[3], mkd.BidPrice[4], mkd.BidPrice[5], mkd.BidPrice[6], mkd.BidPrice[7], mkd.BidPrice[8], mkd.BidPrice[9], mkd.BidVol[0], mkd.BidVol[1], mkd.BidVol[2], mkd.BidVol[3], mkd.BidVol[4], mkd.BidVol[5], mkd.BidVol[6], mkd.BidVol[7], mkd.BidVol[8], mkd.BidVol[9], mkd.NumTrades, mkd.Volume, mkd.Turnover, mkd.TotalBidVol, mkd.TotalAskVol, mkd.WeightedAvgBidPrice, mkd.WeightedAvgAskPrice, mkd.IOPV, mkd.YieldToMaturity, mkd.HighLimited, mkd.LowLimited)
			if err != nil {
				log.Error("error: %v", err)
			}
		} else {
			log.Error("interface转换Marketdata失败：msg.(base.Marketdata)")
		}

		i++
		if i%1000 == 0 {
			tx.Commit()
			log.Error("insert %d with %v", i, time.Now().Sub(t0))

			tx, err = db.Begin()
			if err != nil {
				log.Error("db.Begin err: ", err)
			}

			stmt, err = tx.Prepare("REPLACE INTO realtimemarketdata(Code,Time,Status,PreClose,Open,High,Low,Last,AskPrice1,AskPrice2,AskPrice3,AskPrice4,AskPrice5,AskPrice6,AskPrice7,AskPrice8,AskPrice9,AskPrice10,AskVol1,AskVol2,AskVol3,AskVol4,AskVol5,AskVol6,AskVol7,AskVol8,AskVol9,AskVol10,BidPrice1,BidPrice2,BidPrice3,BidPrice4,BidPrice5,BidPrice6,BidPrice7,BidPrice8,BidPrice9,BidPrice10,BidVol1,BidVol2,BidVol3,BidVol4,BidVol5,BidVol6,BidVol7,BidVol8,BidVol9,BidVol10,NumTrades,Volume,Turnover,TotalBidVol,TotalAskVol,WeightedAvgBidPrice,WeightedAvgAskPrice,IOPV,YieldToMaturity,HighLimited,LowLimited) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)")
			if err != nil {
				log.Error("db.Prepare err: ", err)
			}
		}
	}
}

// 将数据插入redis
func setToRedisForHashMap() {
	data := make(map[string]interface{})
	i := 0
	var code string
	for {
		msg, _ := redisRb.Get()
		log.Info("redisRB.len: %d", redisRb.Len())
		b := msg.([]byte)
		//	code := string(b[14:22])
		//		log.Info("code[%s], b:%v\n", code, b)
		if b[20] != 32 && b[21] != 32 {
			code = string(b[14:22]) + ".SZ"
		} else {
			code = string(b[14:20]) + ".SZ"
		}
		data[code] = string(b)
		if len(data) == 200 {
			md, err := RedisPool.SetHashMap("MarketMap_test", data)
			//	log.Info("data:%v\n", data)
			if err != nil {
				log.Error("insert to HashMap error: ", err)
			}
			log.Info("插入redis数据库成功!插入记录：%v", md)
			for k, _ := range data {
				delete(data, k)
			}
		}
		i++
	}
}

func StartHqserver() {
	flag.Parse()
	var wg sync.WaitGroup
	wg.Add(1)

	log.LoadConfiguration("./conf/quant_log.xml")
	defer log.Close()
	conf = goini.SetConfig("./conf/quant.ini")

	var REDIS = map[string]string{
		"host":         conf.GetValue("redis", "redishost"),
		"database":     conf.GetValue("redis", "database"),
		"password":     conf.GetValue("redis", "password"),
		"maxOpenConns": conf.GetValue("redis", "maxOpenConns"),
		"maxIdleConns": conf.GetValue("redis", "maxIdleConns"),
	}
	RedisPool = redis.InitRedis(REDIS)
	_, err := RedisPool.Do("PING")
	if err != nil {
		log.Info("redis error")
		panic(err)
	}

	rb = queue.NewRingBuffer(9000)
	redisRb = queue.NewRingBuffer(6000)
	mysqlRb = queue.NewRingBuffer(9000)

	go sendToMysql()

	go sendToZMQ()

	go setToRedisForHashMap()

	vss.InitVss(conf)

	go vss.Heartbeat()

	go vss.ReceiveMarketData(redisRb, rb, mysqlRb)

	go readSH.Readfile(conf)

	go readSH.Md001map(rb, mysqlRb)

	go readSH.Md002map(rb, mysqlRb)

	go readSH.Md004map(rb, mysqlRb)
	wg.Wait()
	os.Exit(0)
}

func main() {
	StartHqserver()
}
