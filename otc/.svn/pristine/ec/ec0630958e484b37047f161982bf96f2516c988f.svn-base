#include <Include/t2sdk_interface.h>

CConnectionInterface *g_lpConnection = NULL;
int g_iFileCount = 0;
int g_iIndex = -1;

void PrintUnPack(IF2UnPacker* lpUnPack)
{
	printf("记录行数：           %d\n",lpUnPack->GetRowCount());
	printf("列行数：			 %d\n",lpUnPack->GetColCount());
	while (!lpUnPack->IsEOF())
	{
		for (int i=0;i<lpUnPack->GetColCount();i++)
		{
			char* colName = (char*)lpUnPack->GetColName(i);
			char colType = lpUnPack->GetColType(i);
			if (colType!='R')
			{
				char* colValue = (char*)lpUnPack->GetStrByIndex(i);
				printf("%s:			[%s]\n",colName,colValue);
			}
			else
			{
				int colLength = 0;
				char* colValue = (char*)lpUnPack->GetRawByIndex(i,&colLength);
				printf("%s:			[%s](%d)\n",colName,colValue,colLength);
			}
		}
		lpUnPack->Next();
	}
	
}

class CCallback : public CCallbackInterface
{
public:
	unsigned long  FUNCTION_CALL_MODE QueryInterface(const char *iid, IKnown **ppv);
	unsigned long  FUNCTION_CALL_MODE AddRef();
	unsigned long  FUNCTION_CALL_MODE Release();
	void FUNCTION_CALL_MODE OnConnect(CConnectionInterface *lpConnection);
	void FUNCTION_CALL_MODE OnSafeConnect(CConnectionInterface *lpConnection);
	void FUNCTION_CALL_MODE OnRegister(CConnectionInterface *lpConnection);
	void FUNCTION_CALL_MODE OnClose(CConnectionInterface *lpConnection);
	void FUNCTION_CALL_MODE OnSent(CConnectionInterface *lpConnection, int hSend, void *reserved1, void *reserved2, int nQueuingData);
	void FUNCTION_CALL_MODE Reserved1(void *a, void *b, void *c, void *d);
	void FUNCTION_CALL_MODE Reserved2(void *a, void *b, void *c, void *d);
	int  FUNCTION_CALL_MODE Reserved3();
	void FUNCTION_CALL_MODE Reserved4();
	void FUNCTION_CALL_MODE Reserved5();
	void FUNCTION_CALL_MODE Reserved6();
	void FUNCTION_CALL_MODE Reserved7();
	void FUNCTION_CALL_MODE OnReceivedBiz(CConnectionInterface *lpConnection, int hSend, const void *lpUnPackerOrStr, int nResult);
	void FUNCTION_CALL_MODE OnReceivedBizEx(CConnectionInterface *lpConnection, int hSend, LPRET_DATA lpRetData, const void *lpUnpackerOrStr, int nResult);
	void FUNCTION_CALL_MODE OnReceivedBizMsg(CConnectionInterface *lpConnection, int hSend, IBizMessage* lpMsg);

};
//以下各回调方法的实现仅仅为演示使用
unsigned long CCallback::QueryInterface(const char *iid, IKnown **ppv)
{
	return 0;
}

unsigned long CCallback::AddRef()
{
	return 0;
}

unsigned long CCallback::Release()
{
	return 0;
}
void CCallback::OnConnect(CConnectionInterface *lpConnection)
{
	puts("CCallback::OnConnect");
}

void CCallback::OnSafeConnect(CConnectionInterface *lpConnection)
{
	puts("CCallback::OnSafeConnect");
}

void CCallback::OnRegister(CConnectionInterface *lpConnection)
{
	puts("CCallback::OnRegister");
}

void CCallback::OnClose(CConnectionInterface *lpConnection)
{
	puts("CCallback::OnClose");
}

void CCallback::OnSent(CConnectionInterface *lpConnection, int hSend, void *reserved1, void *reserved2, int nQueuingData)
{

}

void CCallback::OnReceivedBiz(CConnectionInterface *lpConnection, int hSend, const void *lpUnpackerOrStr, int nResult)
{

}
void CCallback::OnReceivedBizEx(CConnectionInterface *lpConnection, int hSend, LPRET_DATA lpRetData, const void *lpUnpackerOrStr, int nResult)
{

}
void CCallback::OnReceivedBizMsg(CConnectionInterface *lpConnection, int hSend, IBizMessage* lpMsg)
{

}
void CCallback::Reserved1(void *a, void *b, void *c, void *d)
{
}

void CCallback::Reserved2(void *a, void *b, void *c, void *d)
{
}
int  CCallback::Reserved3()
{
	return 0;
}

void CCallback::Reserved4()
{
}

void CCallback::Reserved5()
{
}

void CCallback::Reserved6()
{
}

void CCallback::Reserved7()
{
}


class CFileUpdateCallback : public CFileUpdateCallbackInterface
{
	unsigned long  FUNCTION_CALL_MODE QueryInterface(const char *iid, IKnown **ppv)
	{
		return 0;
	}
    unsigned long  FUNCTION_CALL_MODE AddRef()
	{
		return 0;
	}
    unsigned long  FUNCTION_CALL_MODE Release()
	{
		return 0;
	}

  /**
    * 收到更新文件列表的回调
    * @param lpData 返回二进制指针
    * @param nLength 二进制数据的长度，如果为负数则为错误码
	* @param lpErrorInfo 如果不为NULL则为错误信息，发生错误，应该先去看错误信息，如果没有再去拿错误码信息
    * @return 无
    */
     void FUNCTION_CALL_MODE OnRecvFileList(const void *lpData, int nLength, const char * lpErrorInfo) ;

   /**
    * 收到通知文件更新进度
    * @param iOneFileProcessBar 当前文件进度
    * @param iTotalProcessBar 总进度
	* @param lpErrorInfo 如果不为NULL则为错误信息，发生错误，应该先去看错误信息，如果没有再去拿错误码信息
    * @return 无
    */
     void FUNCTION_CALL_MODE OnShowProcessBar(int iOneFileProcessBar, int iTotalProcessBar, const char * lpErrorInfo) ;
	
	/**
    * 收到成功取消文件更新
    * @return 无
    */
     void FUNCTION_CALL_MODE OnCancel()
     {
     	}
};

 void CFileUpdateCallback::OnRecvFileList(const void *lpData, int nLength,const char * lpErrorInfo)
 {
 	//收到文件列表
 	IF2UnPacker *unPacker = NewUnPacker((void *)lpData, nLength);
	unPacker->AddRef();
	g_iFileCount = unPacker->GetRowCount();
	PrintUnPack(unPacker);
	unPacker->Release();
 }
	void CFileUpdateCallback::OnShowProcessBar(int iOneFileProcessBar, int iTotalProcessBar,const char * lpErrorInfo)
	{
		
		if (iOneFileProcessBar == 100)
		{
	      g_iIndex++;
				printf("第%d个文件更新成功！\n", g_iIndex);
		}else if (iOneFileProcessBar <= -1 || iTotalProcessBar == -1 || iOneFileProcessBar > 100 || lpErrorInfo != NULL)
		{
			if(lpErrorInfo)
				 printf("errorInfo:%s \n",lpErrorInfo);
			g_iIndex++;		
			printf("第%d个文件更新失败，错误号为%d！\n", g_iIndex,iOneFileProcessBar);
		}
		printf("当前文件：%d，总进度：%d\n",iOneFileProcessBar,iTotalProcessBar);
		if (iTotalProcessBar == 100 && g_iIndex - 1 == g_iFileCount)
		{
        // MessageBox(g_FileUpdateDlg->m_hWnd,"下载成功！", "提示",0);
		     printf("下载成功！\n");
		}
	}



int main()
{

//	CPreThread CountThread;
    //通过T2SDK的引出函数，来获取一个新的CConfig对象指针
    //此对象在创建连接对象时被传递，用于配置所创建的连接对象的各种属性（比如服务器IP地址、安全模式等）
    //值得注意的是，在向配置对象设置配置信息时，配置信息既可以从ini文件中载入，
    //也可以在程序代码中设定，或者是2者的混合，如果对同一个配置项设不同的值，则以最近一次设置为准
    CConfigInterface * lpConfig = NewConfig();
	  lpConfig->AddRef();
    lpConfig->Load("fileupdate.ini");
	//如果需要使用发布订阅功能，必须配置配置mc标签下面的client_name项，配置文件里面有了，不需要下面这句代码添加
	//lpConfig->SetString("mc","client_name","xuxp");

    //通过T2SDK的引出函数，来获取一个新的CConnection对象指针
    g_lpConnection = NewConnection(lpConfig);
    g_lpConnection->AddRef();

    //创建自定义类CCallback的对象（在创建连接时需传递此对象，请看下面代码）
    CCallback callback;

    int ret = 0;

    //初始化连接对象，返回0表示初始化成功，注意此时并没开始连接服务器
    if (0 == (ret = g_lpConnection->Create(&callback)))
    {
        //正式开始连接，参数1000为超时参数，单位是ms
        if (ret = g_lpConnection->Connect(1000))
        {
            puts(g_lpConnection->GetErrorMsg(ret));
        }
        else
        {
							CFileUpdateCallback updateCallback;
							char* lpTopicName = (char*)lpConfig->GetString("fileupdate","topic","secu.file_update");
							char* lpUpdatePath = (char*)lpConfig->GetString("fileupdate","updatedir","./updatedir");
							char* lpScanPath = (char*)lpConfig->GetString("fileupdate","scandir","./scandir");
							CFileUpdateInterface* lpFileUpdate = g_lpConnection->NewFileUpdate(lpTopicName,&updateCallback,lpScanPath,lpUpdatePath);
							if (!lpFileUpdate)
							{
								printf("FileUpdate Error: %s\n",g_lpConnection->GetFileUpdateLastError());
							}
							else
							{
								  printf("可以来输入了,在等待文件列表到来！\n");
								  getchar();
									lpFileUpdate->AddRef();
									//在此处只是为了简单所以取了所有更新文件列表，
									//这个一般来说由客户选择决定更新那些文件然后按照下面的打包方式打包传给接口
									IF2UnPacker *unPacker = lpFileUpdate->GetFileUpdateList(); //取了所有文件列表
									IF2Packer *packer = NewPacker(2);
									packer->AddRef();
				          packer->BeginPack();
							    packer->AddField(PACKER_INT_FILE_LIST);
							    packer->AddField(PACKER_INT_FILE_ID);
							    packer->AddField(PACKER_INT_FILE_SIZE);
							    packer->AddField(PACKER_INT_TIME);
							    packer->AddField(PACKER_STRING_FILE_NAME);
							    packer->AddField(PACKER_STRING_FILE_PATH);
							    packer->AddField(PACKER_STRING_LOCAL_PATH);
							    packer->AddField(PACKER_STRING_MD5_CODE);
							
							    while (unPacker->IsEOF() == 0)
							    {      
							        /* 打包 */
							        packer->AddInt(unPacker->GetInt(PACKER_INT_FILE_LIST));
							        packer->AddInt(unPacker->GetInt(PACKER_INT_FILE_ID));
							        packer->AddInt(unPacker->GetInt(PACKER_INT_FILE_SIZE));
							        packer->AddInt(unPacker->GetInt(PACKER_INT_TIME));
							        packer->AddStr(unPacker->GetStr(PACKER_STRING_FILE_NAME));
							        packer->AddStr(unPacker->GetStr(PACKER_STRING_FILE_PATH));
							        packer->AddStr(unPacker->GetStr(PACKER_STRING_LOCAL_PATH));
							        packer->AddStr(unPacker->GetStr(PACKER_STRING_MD5_CODE));
							        unPacker->Next();
							    }
				          packer->EndPack();
									lpFileUpdate->UpdateFile(packer);
									packer->FreeMem(packer->GetPackBuf());
									packer->Release();
								  getchar();
							    lpFileUpdate->Release();
									
							}
	      }
    }
    else
    {
        puts(g_lpConnection->GetErrorMsg(ret));
    }
	
    //通过getchar阻塞线程，等待服务端应答包到达
    getchar();
    g_lpConnection->Release();
    lpConfig->Release();
    return 0;
}
